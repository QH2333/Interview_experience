<!--
 * @Author: tylerytr
 * @Date: 2023-07-31 11:41:03
 * @LastEditors: tylerytr
 * @LastEditTime: 2023-08-26 11:37:38
 * @FilePath: /Interview_experience/C++基架后端/系统部分答案.md
 * Email:601576661@qq.com
 * Copyright (c) 2023 by tyleryin, All Rights Reserved. 
-->
# 系统

## 体系结构
1. 增加CPU的数量，会对CPU密集型或IO密集型的任务性能处理有提升吗？
> CPU密集型有提升大，IO密集型提升小或没有提升

2. CPU多级缓存，为什么这么设计？
> 单级缓存无法同时做到访问速度快（需要尽可能贴近CPU）、容量大（需要占用更大的面积），用多级缓存可以利用局部性原理同时满足快速和大容量，工业实践的结果认为3级缓存比较平衡

3. 用户态和内核态区别是什么？
> 内核态/用户态本质上是CPU执行指令的特权级，内核态可以执行一些特权指令

4. 用户态和内核态切换的主要开销在哪里
> 保存寄存器（直接开销小）、检查权限、打乱执行流（间接开销小）、切换到内核栈（缓存冷，间接开销大），如果是系统调用还需要来回拷贝参数（直接开销大）

5. 同步IO和异步IO的区别，阻塞IO和非阻塞IO的区别，是否存在同步非阻塞IO？
> 同步/异步IO 的区别在于数据搬运 是/否 由调用IO函数的进程完成
> 非阻塞/阻塞IO 的区别在于IO未准备好时函数调用 会/不会 立即返回；同步非阻塞就是轮询
> 可以参考[该博客](https://www.cnblogs.com/loveer/p/11479249.html)

6. 物理地址在cache中的映射关系
> 1. cache中映射的内容与CPU架构有关，intel的实现是L1按虚拟地址寻址，但是有物理地址tag，L2/3按物理地址寻址
> 2. 根据内存地址找cache的通过过程：内存地址空间可以划分为**tag**+(setindex)+blockoffset;cacheline中的数据结构为**tag**+dirtybit+data;因此找cache的流程是：(通过setindex确定cacheline对应的组)，然后比对tag是否一致，如果一致的话根据blockoffset得到数据；PS:()部分全相联没有。
> 3. cache 地址映射：目的是把内存地址空间映射到Cache地址空间。可以分为全关联型cache，直接关联型cache以及组关联型cache。不同的方案内部存储的结构不一样。需要考虑不同关联关系主存地址(20位)的划分,CPU如何根据内存地址确认对应的cache，具体可以参考[该专栏](https://zhuanlan.zhihu.com/p/431243686)
>     1. 全关联型cache；主存地址=tag+blockoffset；cache被划分成一个set；主存中的一个block可以映射到任意一个cacheline
>     2. 直接关联型cache；主存地址=tag+setindex+blockoffset；cache被划分成n个set；cache被组织成多个sets(组)，每个set只有一个cache line。每个Main Memory的地址只对应一个Cache line。
>     3. 组关联型cache；主存地址=tag+setindex+blockoffset；cache被分为n个set,每个set包含m条Cache line。一个Main Memory首先被映射到一个set中，然后被放到这个Set的任意一条Cache line中。

## 操作系统
[linux内核数据结构](http://www.embeddedlinux.org.cn/linuxkernel/ds/ds.html)
1. 操作系统有哪些主要功能？
> 进程和线程的管理,存储管理,文件管理,设备管理,用户接口

2. 常见的系统调用？
> 文件操作系统的系统调用(create,open,read,write,close,link,unlink,lseek,chmod,rename)
> 控制类的系统调用(fork,wait,exit,exec)
> 信号和时间类的调用(kill,sigaction,sigreturn,stime,time,times)
> 这里有一个[完整版本](https://filippo.io/linux-syscall-table/)

3. 什么是零拷贝？
> 通过网卡传输磁盘文件的场景：
> - 传统需要4次内存拷贝（磁盘-内核态-用户态-内核态-网卡），其中中间两次需要CPU参与（内核态-用户态-内核态）
> - 使用mmap+write()可以消除内核态-用户态拷贝
> - 使用sendfile()可以消除所有CPU参与的拷贝（磁盘-内核态-网卡，两次拷贝都由硬件DMA完成）
> 可以参考[我的博客](https://tyler-ytr.github.io/2022/04/16/RDMA-learning/#DMA%E6%8A%80%E6%9C%AF%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D)

## 进程管理

1. 进程和线程区别和联系
> 基本单位：进程是资源分配的基本单位，线程是CPU任务调度的基本单位
> 资源：进程拥有完整的虚拟空间（代码段，数据段，堆，栈，文件映射表），内核的一些数据结构（页表，[mm结构](https://blog.csdn.net/FF_programming/article/details/120963212)，[内核栈](https://www.zhihu.com/question/57013926/answer/151306072)，[task](https://ty-chen.github.io/linux-kernel-task-struct/)）；线程除用户栈，程序计数器PC，栈指针和函数运行使用的寄存器私有，其他都和进程其他线程共享。
> 切换开销：进程需要切换上述提到的所有资源，因此开销更大。
> 隔离性：进程崩溃不会影响其他线程，线程崩溃会导致进程崩溃，如果线程屏蔽segment fault信号，且崩溃在私有区域，那么其他线程不会崩溃
> 通信方式：进程通信（共享内存仅注册）需要进入内核态，线程只需要在进程虚拟空间。
> Linux中线程就是轻量级进程，都用task_struct描述，线程共享虚拟内存、文件、信号等多数进程资源，但独立调度

2. Python/Java/C++里面的线程有什么不一样？
> C++线程就是系统线程，Python/Java都是虚拟机封装后的系统线程（尽管都是一对一的），Python(中的Cpython)由于有GIL所以多线程只能提升IO不能提升计算性能

3. 时间片是什么
> 操作系统调度到一个进程时，给进程分配的执行时间

4. 进程、线程、协程切换的开销分别是什么
> 进程：切换硬件上下文，内核栈，虚拟内存空间，页表，TLB；间接开销（冷cache）
> 线程：切换硬件上下文，内核栈，用户栈指针
> 协程：切换用户态上下文;开销几十ns
5. 进程通信方式
> [进程通信例程](https://blog.csdn.net/qq_38048756/article/details/109394362)

6. 讲讲 fork() 函数
> 现在 fork() 是基于 clone() 实现，大体流程
> - 给子进程创建一个task_struct
> - 复制虚拟空间：代码段，数据段，堆，栈，文件描述表
> - 复制变量：gid，uid，信号处理，环境变量，工作目录
> - 添加子进程到就绪队列
> - 返回子进程id

7. Linux 杀死进程的过程
> 可以用 kill 工具向进程发送信号来杀死进程，底层调用的是 kill 系统调用
> `kill -9 test`，发送 SIGKILL 信号给程序，程序无法做出反应直接退出
> `kill -15 test`，也就是 SIGTERM，程序可以捕获信号，根据自定义的信号处理函数做退出处理

8. 知道哪些信号，什么时候产生？
> 可以使用 `kill -l` 查看
> SIGINT Crtl+C
> SIGQUIT Ctrl+\
> SIGTSTP Crtl+Z
> SIGHUP 控制终端退出
> SIGURG 收到TCP Urgent报文

9. 什么是协程？
10. 讲一讲调度算法。调度算法调度的是什么？目前Linux使用的是哪一个呢？
11. int i;while(true){i++;} 在自己的电脑上一秒钟大概的值；怎么估算；
> 方向和cpu频率有关大概

## 内存管理
1. 操作系统页面置换算法
> 未来最长时间不访问算法：最佳页面置换算法，不可能实现
> 先进先出（FIFO）：最naive的
> 最近最久未使用的置换算法（LRU）：需要置换页面时，选择最近最少被访问的页面。需要维护一个链表，置换时候插入删除开销大
> 最不常用算法（LFU）：需要置换页面时，选择最不经常被访问的页面。每个页面设置计数寄存器，开销大
> 时钟页面置换算法：遍历，1改为0，0换出

2. 分段机制、分页机制，缺页中断、为什么有页表
> 1. 分段可以方便的将程序加载到一段连续的内存上，符合程序的本意，一段内存一段程序，缺点内存碎片多
>     * 虚拟地址 = 段号 + 段内偏移，段表转转换段号->段首地址
>     * 物理地址 = 段首地址 + 段内偏移
> 2. 分页可以解决碎片问题，缺点页表占空间（解决：多级页表）
>     * 虚拟地址 = 虚拟页号 + 页内偏移，页表转换虚拟页号->物理页号
>     * 物理地址 = 物理页号 * 4KB + 页内偏移

3. 操作系统里面分配内存和管理内存，怎么做的？如果是多核的情况应该怎么优化呢？
> 物理内存管理：伙伴系统 buddy system，可以分配出 2^n 个连续的物理内存页框
> 内核虚拟内存管理：slab，可以解决小对象频繁分配的问题
> 用户态虚拟内存管理：用brk()和mmap()系统调用申请用户态虚拟内存，malloc()提供了小对象内存池，程序也可以自行实现内存池

4. 为什么需要虚拟内存？
> 1. 隔离不同进程的地址空间，如果不隔离，永远不可能并发执行
>     * 同样的程序如果都往0xa里写，那会冲突
> 3. 确定程序地址，避免不确定的物理地址，方便编程
> 2. 提高内存使用效率
>     * 分页，一次只需要加载一部分页面 
>     * 多个进程共享内存空间

5. malloc()底层涉及了什么系统调用？mmap和brk的区别？
> brk和mmap;brk负责小于128KB; mmap负责大于128KB; 另外malloc(1)会申请不止1字节;对于brk申请的内容free了之后也不会归还系统，而是放回malloc自己维护的内存池里面。参考[小林](https://www.xiaolincoding.com/os/3_memory/malloc.html)

## 文件系统

1. write操作发生了什么
>  1. 可以参考[该专栏](https://zhuanlan.zhihu.com/p/142441899)
>  2. 关键技术是内核缓冲区。
>  3. 简要而言：write操作会1.调用系统调用2.系统调用会调用vfs_write然后返回；3. 此时数据会进入内核缓冲区；操作系统会在后台收集所有的“脏”数据按照顺序在某一个时刻写入磁盘。写入的时机包括：1.脏页超过上限2.dirty_expire_interval超时;

2.  write的用户态内核态操作，数据要拷贝到内核态吗，如果突然宕机了会有没写的吗？怎么刷新缓冲区呢？这块系统调用是什么呢？
> 如何保证落盘，参考[该文章](https://www.markjour.com/article/20221110-linux-sync.html)；文件数据从应用程序写入磁盘，需要经过多个缓冲区：应用本身的缓冲区，库的缓冲区，操作系统缓冲区，磁盘缓冲区；还在缓冲区的时候掉电就会丢失数据
> 可以使用fsync/fdatasync系统调用刷新缓冲区，在开启写屏障的时候能够写入持久化设备(不开启的话可能会在磁盘缓存里面)

3.  讲一讲怎么看文件权限？文件权限是怎么实现的？
> 1. `ls -l` / `stat`
> 2. 文件权限位于inode中；关于linux文件权限的更多内容可以参考[Linux文件权限](https://tyler-ytr.github.io/2023/04/25/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/#%E8%A1%A5%E5%85%85%EF%BC%9ALinux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90)
> 3. 文件权限用数字或者字母表示，分别是4(r)、2(w)、1(x)。数字4表示读取权限，数字2表示写入权限，数字1表示执行权限。例如，数字755(rwxr-xr-x)表示所有者(4+2+1=7)有读取、写入和执行权限，用户组(4+1)和其他用户(4+1)只有读取和执行权限。

4. Linux 文件描述符 vs. 文件句柄
> 文件句柄也被称为文件指针，文件指针指向进程用户区中的一个被称为FILE结构的数据结构。FILE结构包括一个缓冲区和一个文件描述符。而文件描述符是文件描述符表的一个索引。

5. 基本的IO模型有哪些
> 阻塞/非阻塞，同步/异步，IO多路复用，

6. 文件描述符有哪些种类？
> 有三种文件描述符表：进程级的文件描述符表，系统级的打开文件描述符表，文件系统的i-node表。
> 进程描述符表条目指向系统描述符表条目，系统描述符表条目指向inode表条目，inode表条目指向inode。

## 并发
1. 什么是线程安全？
> 线程安全是函数（或者类）的属性，在多线程共享数据的场景下，如果并发调用函数（或类方法）仍然可以保证执行结果正确，则函数（或者类）是线程安全的
> 如果没有共享数据，那肯定是线程安全的

2. 服务器多线程如何防止数据冲突
> 如果可以的话，使用 thread_local 消除数据共享
> 如果一定需要共享数据，有几种方法：1）使用原子操作修改变量；2）使用CAS指令实现无锁数据结构；3）加锁来创造临界区

3. 死锁产生的条件；设计一种通用性算法，怎么检测一个死锁；
> 产生条件：资源互斥，不可剥夺，环路等待，已经获得的资源不会因为阻塞而主动释放。
> 死锁避免：银行家算法
> 死锁检测：资源分配图

4. 说说(Java)ThreadLocal或(C++)thread_local
> 修饰后的全局变量会变成线程私有，每个线程创建的时候都会获得自己的一份拷贝，存放在堆上，对同进程其他线程不可见

5. (Java) 多线程wait notify join
> TODO

## Linux 使用
1. 用 cat 和 grep 根据关键字查找日志
> `cat filename.txt | grep xxx`
> grep `-v` 可以反选 

2. grep 查找前边的十行，用什么参数
> `-B 10`，注意 grep 指令 -A/-B 参数的含义是 After/Before，不是 Above/Below

3. 用什么工具调试内存泄漏，怎么定位？
> AddressSanitizer，gcc 和 clang 都自带，在编译的时候加上 -fsantizer=address 参数就行，Leetcode 的内存泄漏检测就是用的 ASan
> Valgrind，是一整套调试工具的集合，其中 Memcheck 可以检测内存泄露，编译的时候不需要加参数，但是性能下降比 Asan 严重得多

4. Git 底层
> TODO
5. 是否用过 Linux，常用命令
6. 你觉得linux操作系统可以怎么改进
> [Linux内核协议栈性能瓶颈](https://blog.51cto.com/quantfabric/2594168)：(进程线程;网络;多处理器;缓存)
> 1. 硬件中断导致的线程、进程切换;硬件中断请求会抢占优先级较低的软件中断，频繁到达的硬件中断和软中断意味着频繁的线程切换，随着而来的就是运行模式切换、上下文切换、线程调度器负载、高速缓存缺失（Cache Missing）、多核缓存共享数据同步、竞争锁等一系列的CPU性能损耗。
> 2. 内存拷贝;网卡驱动位于内核态，网络驱动接收到数据包后会经过内核协议栈的处理，然后再拷贝到用户态的应用层缓冲区.从内核态到用户态的数据拷贝是耗时操作，数据拷贝的时间会占数据包处理流程时间的50%以上。
> 3. 多处理器平台CPU漂移;一个数据包可能中断在CPU0，内核态处理在CPU1，用户态处理在 CPU2，跨多个物理核（Core）处理会导致大量的 CPU Cache命中缺失，造成局部性失效。对于NUMA架构，还会出现跨NUMA节点的内存访问，极大地影响CPU性能。
> 4. 缓存失效;传统服务器大多采用页式虚拟存储器，内存页默认为4K的小页，在存储空间较大的处理机上会存在大量的页面映射项。同时由于TLB缓存空间有限，最终导致TLB快表的映射项频繁变更，产生大量的TLB命中缺失。
> 潜在的解决方法:
> 1. Kernel Bypass(内核旁路):绕过Linux内核（TCPIP协议栈）的技术，不使用Linux内核子系统的功能，采用自己实现的相同功能的代码来处理，从用户空间直接访问和控制设备内存，避免数据从设备拷贝到内核，再从内核拷贝到用户空间。主要的实现方案包括:DPDK;SolarFlare;
> 2. XDP(eXpress Data Path),是一种依赖于eBPF的内核代码注入技术，能够在网络包到达内核协议栈前对网络包进行过滤或者处理。。XDP将网络包处理流程放到Linux内核中位于网络协议栈前的位置，在处理网络数据包时，不用经过网络协议栈的复杂流程，同时又保留了操作系统控制网络硬件的能力。
> 3. Solarflare网卡支持OpenOnload网卡加速器，其Kernel Bypass实现方案如下：在用户空间实现网络协议栈，并使用LD_PRELOAD覆盖目标程序的网络系统调用，而在底层访问网卡时依靠EF_VI库。
7. linux里netfilter的原理是什么?
8. linux启动gui还是文本框是怎么区分的？
9.  linux中sudo提权的原理是什么？
> 如果文件拥有s权限，那么可以让使用者拥有创建该文件的用户的权限。sudo是一个拥有者为root并且拥有s权限的可执行文件。可以参考[我的博客](https://tyler-ytr.github.io/2023/04/25/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/#%E8%A1%A5%E5%85%85%EF%BC%9ALinux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86)
10.  linux实现软路由的原理是什么？
11.  linux login之后的程序是什么？
